plugins {
    id 'fabric-loom' version "${loom_version}"
    id 'maven-publish'
    id 'signing'
}

// Function to increment the patch version directly
def getIncrementedVersion() {
    def propertiesFile = file('gradle.properties')
    def props = new Properties()
    propertiesFile.withInputStream { props.load(it) }

    // Get current version and parse it
    def currentVersion = props.getProperty('mod_version')
    def versionParts = currentVersion.split('\\.')

    // Increment the patch version (last number)
    def major = versionParts[0] as int
    def minor = versionParts[1] as int
    def patch = (versionParts.length > 2 ? versionParts[2] as int : 0) + 1

    // Create new version
    def newVersion = "${major}.${minor}.${patch}"

    // Update the gradle.properties file
    props.setProperty('mod_version', newVersion)
    propertiesFile.withOutputStream {
        props.store(it, "Gradle properties - auto-updated mod_version")
    }

    return newVersion
}

// Remove the existing incrementVersion task and its dependency

// Instead, increment version at configuration time when building
if (gradle.startParameter.taskNames.contains('build') || 
    gradle.startParameter.taskNames.any { it.contains('publish') }) {
    version = getIncrementedVersion()
} else {
    version = project.mod_version
}

// Remove these lines:
// tasks.register('incrementVersion') { ... }
// tasks.named('build') { dependsOn 'incrementVersion' }

// For other tasks, use the current version from properties
group = project.maven_group

base {
    archivesName = project.archives_base_name
}

repositories {
    // Add repositories to retrieve artifacts from in here.
    // You should only use this when depending on other mods because
    // Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
    // See https://docs.gradle.org/current/userguide/declaring_repositories.html
    // for more information about repositories.
    maven {
        name = "GitHubPackages"
        url = "https://maven.pkg.github.com/MurkyConspiracy/MurkysManyAPIs"
        credentials {
            username = System.getenv("GITHUB_ACTOR")
            password = System.getenv("GITHUB_TOKEN")
        }
    }
}

loom {
    splitEnvironmentSourceSets()

    mods {
        "murkysmanyapis" {
            sourceSet sourceSets.main
            sourceSet sourceSets.client
        }
    }
}

fabricApi {
    configureDataGeneration {
        client = true
    }
}

dependencies {
    // To change the versions see the gradle.properties file
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
    modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

    // Fabric API. This is technically optional, but you probably want it anyway.
    modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"
}

processResources {
    inputs.property "version", project.version

    filesMatching("fabric.mod.json") {
        expand "version": project.version
    }
}

tasks.withType(JavaCompile).configureEach {
    it.options.release = 21
}

// Generate checksums for all JAR artifacts
tasks.withType(Jar).configureEach { jarTask ->
    jarTask.doLast {
        def jarFile = jarTask.archiveFile.get().asFile
        if (jarFile.exists()) {
            ant.checksum(algorithm: 'md5', file: jarFile)
            ant.checksum(algorithm: 'sha1', file: jarFile)
            println "Generated checksums for: ${jarFile.name}"
        }
    }
}
java {
    // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
    // if it is present.
    // If you remove this line, sources will not be generated.
    withSourcesJar()
    withJavadocJar()

    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

jar {
    inputs.property "archivesName", project.base.archivesName

    from("LICENSE") {
        rename { "${it}_${inputs.properties.archivesName}" }
    }
}

// configure the maven publication
publishing {
    publications {
        create("mavenJava", MavenPublication) {
            groupId = project.maven_group
            artifactId = project.archives_base_name
            version = project.version
            
            from components.java
            
            // Debug output
            println "Creating publication with:"
            println "  GroupId: ${groupId}"
            println "  ArtifactId: ${artifactId}"
            println "  Version: ${version}"
            
            pom {
                name = 'Murky\'s Many APIs'
                description = 'A Fabric mod providing various APIs'
                url = 'https://github.com/MurkyConspiracy/MurkysManyAPIs'
                
                licenses {
                    license {
                        name = 'MIT License'
                        url = 'https://opensource.org/licenses/MIT'
                    }
                }
                
                developers {
                    developer {
                        id = 'MurkyConspiracy'
                        name = 'Laura'
                        email = 'nickreeder43@gmail.com'
                    }
                }
                
                scm {
                    connection = 'scm:git:git://github.com/MurkyConspiracy/MurkysManyAPIs.git'
                    developerConnection = 'scm:git:ssh://github.com/MurkyConspiracy/MurkysManyAPIs.git'
                    url = 'https://github.com/MurkyConspiracy/MurkysManyAPIs'
                }
            }
        }
    }
    
    repositories {
        maven {
            name = "OSSRH"
            url = "https://repo1.maven.org/maven2/org/sonatype/central/"
            credentials {
                username = System.getenv("MAVEN_USERNAME")
                password = System.getenv("MAVEN_PASSWORD")
            }
        }
        maven {
            name = "GitHubPackages"
            url = "https://maven.pkg.github.com/MurkyConspiracy/MurkysManyAPIs"
            credentials {
                username = System.getenv("GITHUB_ACTOR")
                password = System.getenv("GITHUB_TOKEN")
            }
        }
        maven {
            name = "LocalMavenWithChecksums"
            url = uri(layout.buildDirectory.dir("staging-deploy"))
        }
    }
}

// Replace your existing signing block with this:
signing {
    def keyId = System.getenv("GPG_KEY_ID")
    def password = System.getenv("GPG_PASSPHRASE")
    def keyFile = System.getenv("GPG_KEY_FILE")

    if (keyId && password) {
        // If using GPG command line
        useGpgCmd()
        sign publishing.publications.mavenJava
    } else if (keyFile && password) {
        // If using key file
        def secretKeyRingFile = file(keyFile)
        useInMemoryPgpKeys(secretKeyRingFile.text, password)
        sign publishing.publications.mavenJava
    } else if (project.hasProperty("signing.keyId")) {
        // If using gradle.properties
        sign publishing.publications.mavenJava
    } else {
        // Force signing for Maven Central
        useGpgCmd()
        sign publishing.publications.mavenJava
    }
}

// Ensure signing happens before publishing
tasks.withType(PublishToMavenRepository) {
    dependsOn tasks.withType(Sign)
}


// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
repositories {
    // Add repositories to publish to here.
    // Notice: This block does NOT have the same function as the block in the top level.
    // The repositories here will be used for publishing your artifact, not for
    // retrieving dependencies.
}

// Add checksums for remapped jars specifically
tasks.named('remapJar') {
    doLast {
        ant.checksum algorithm: 'md5', file: archiveFile.get().asFile
        ant.checksum algorithm: 'sha1', file: archiveFile.get().asFile
    }
}

tasks.named('remapSourcesJar') {
    doLast {
        ant.checksum algorithm: 'md5', file: archiveFile.get().asFile
        ant.checksum algorithm: 'sha1', file: archiveFile.get().asFile
    }
}

// Add this task to copy the generated POM to build/libs
tasks.register('copyPomToLibs', Copy) {
    dependsOn 'generatePomFileForMavenJavaPublication'
    from layout.buildDirectory.file('publications/mavenJava/pom-default.xml')
    into layout.buildDirectory.dir('libs')
    rename 'pom-default.xml', "${project.archives_base_name}-${project.version}.pom"
    
    doLast {
        def pomFile = new File(layout.buildDirectory.dir('libs').get().asFile, "${project.archives_base_name}-${project.version}.pom")
        if (pomFile.exists()) {
            ant.checksum algorithm: 'md5', file: pomFile
            ant.checksum algorithm: 'sha1', file: pomFile
            println "Generated checksums for: ${pomFile.name}"
        }
    }
}

// Make build depend on copying the POM
tasks.named('build') {
    dependsOn 'copyPomToLibs'
}

// Add this task at the end of your build.gradle file
tasks.register('publishAndTar', Tar) {
    description = 'Publishes to local staging repository and creates a tar archive'
    group = 'publishing'
    
    // First run the publish task
    dependsOn 'publishMavenJavaPublicationToLocalMavenWithChecksumsRepository'
    
    // Configure the tar
    from layout.buildDirectory.dir("staging-deploy")
    into "${project.archives_base_name}-${project.version}-staging"
    archiveFileName = "${project.archives_base_name}-${project.version}-staging.tar"
    destinationDirectory = layout.buildDirectory.dir("distributions")
    
    // Ensure the staging directory exists before trying to tar it
    doFirst {
        def stagingDir = layout.buildDirectory.dir("staging-deploy").get().asFile
        if (!stagingDir.exists()) {
            throw new GradleException("Staging directory does not exist: ${stagingDir}")
        }
        println "Creating tar archive from: ${stagingDir}"
        println "Output location: ${archiveFile.get().asFile}"
    }
    
    doLast {
        println "Tar archive created: ${archiveFile.get().asFile}"
        println "Archive size: ${archiveFile.get().asFile.size()} bytes"
    }
}

// Optional: Create a compressed tar.gz version
tasks.register('publishAndTarGz', Tar) {
    description = 'Publishes to local staging repository and creates a compressed tar.gz archive'
    group = 'publishing'
    
    dependsOn 'publishMavenJavaPublicationToLocalMavenWithChecksumsRepository'
    
    from layout.buildDirectory.dir("staging-deploy")
    into "${project.archives_base_name}-${project.version}-staging"
    archiveFileName = "${project.archives_base_name}-${project.version}-staging.tar.gz"
    destinationDirectory = layout.buildDirectory.dir("distributions")
    compression = Compression.GZIP
    
    doFirst {
        def stagingDir = layout.buildDirectory.dir("staging-deploy").get().asFile
        if (!stagingDir.exists()) {
            throw new GradleException("Staging directory does not exist: ${stagingDir}")
        }
        println "Creating compressed tar.gz archive from: ${stagingDir}"
    }
    
    doLast {
        println "Compressed tar.gz archive created: ${archiveFile.get().asFile}"
        println "Archive size: ${archiveFile.get().asFile.size()} bytes"
    }
}
tasks.register('createMavenBundle', Zip) {
    description = 'Creates a Maven Central compatible bundle'
    group = 'publishing'
    
    dependsOn 'publishMavenJavaPublicationToLocalMavenWithChecksumsRepository'
    
    from layout.buildDirectory.dir("staging-deploy")
    archiveFileName = "${project.archives_base_name}-${project.version}-bundle.zip"
    destinationDirectory = layout.buildDirectory.dir("distributions")
    
    doLast {
        println "Maven bundle created: ${archiveFile.get().asFile}"
    }
}